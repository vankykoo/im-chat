# README

一个基于 Netty、spring cloud、nacos、MySQL、Redis、RabbitMQ、kafka 的分布式即时通讯项目。

致力于打造一个 保证消息可靠、安全、有序 的即时通讯系统。



## 一、项目目录

```
① im-auth：认证服务	20007
②im-client：消息客户端		20002
③im-common：项目通用服务	
④im-gateway：网关服务	8088
⑤im-leaf：分布式id生成服务		20090
⑥im-mq：消息队列服务		20005
⑦im-server：消息服务端	20001
⑧im-user：用户管理服务	20000
```



## 二、消息的可靠性保证

### 1）防丢失【发送消息要求接收方ack + 消息重发机制】

【消息未收到 ack 的情况】

1. 发送一条消息后，将消息体存入到 redis 中，并将消息的【uniqueId 和 重发次数】放入 RabbitMQ 消息队列中。
2. 延迟队列中的 【uniqueId 和 重发次数】在规定客户端ack时间内， 会被放入到死信队列，用于检查是否 收到ack消息。
3. 死信队列收到 【uniqueId 和 重发次数】


1. 1. 到 redis 中检查这条消息体是否还存在，存在则说明还没有收到ack
   2. 再检查 重发次数，如果重发次数已达上限，报异常【重试发送多次消息失败】
   3. 如果还没到重发次数上限，就进入消息重发。



【消息收到 ack 后的处理】

（私信）

1. 删除 redis 中的等待ack 的消息体，这样死信队列在检查的时候没有查到这条消息体，说明消息已经ack
2. 修改消息状态 为【已送达】。

（群聊）

1. 修改用户的last_ack_id
2. 删除消息体缓存



### 2）防乱序

1. 单聊：需要在客户端生成顺序的id来保证消息的时序。
2. 群聊：需要在服务端生成顺序的id来保证消息的时序。（发送方不单点）

### 3）防重复

1. 服务端收消息时，检验消息是否已经收过



## 三、消息发送流程

1. 用户上线拉取离线消息


1. 1. 拉取私信离线消息【拉】
   2. 拉取群聊离线消息【拉】 


1. 1. 1. 其实算是登录时进行推送。
      2. 先推送一条一个群聊的离线消息的信息。
      3. 再推送每个群聊的全量离线消息，进行分页推送，每次100条。


1. 1. 1. 如果中间有一条发送失败了怎么办？???        ===>  只能一次获取100条了，不用全量获取，发送完一条之后，等到ack再推送下一条吧。


1. 1. 4. 发送后等待客户端返回ack。



2. 用户发送私信

客户端发送数据，服务端进行id去重，消息入库。入库后 返回ack。

※ **检测对方是否在线。**

1. 1. 对方在线【推】：直接推送。

​             如果不在当前客户端，发生转发信息。

1. 2. 对方离线【存】：存到数据库。等用户上线后拉取离线消息。



3. 用户发送群聊信息


1. 1. 在线用户【推】
   2. 离线用户【存】



## 四、客户端阅读消息

### 1）私信

1. 客户端发送 自己的 id 和 对方的id
2. 服务端到数据库把未读【status=0】消息设置为已读【status=1】即可。（原子操作）

### 2）群聊

1. 客户端还是发送自己的id 和 群聊id即可
2. 服务端到数据库把 last_read_msg_id 设置为 last_ack_msg_id 即可。



## 五、消息安全性保证

参考：<http://www.52im.net/thread-970-1-1.html>

### 1）消息传输过程

1. 双方用户在加好友 / 进入群聊的时候 获取秘钥。客户端保存到本地。
2. 客户端 发送数据到 客户端 前，先获取本地秘钥给消息加密，再传给服务端
3. 服务端转发给 消息接收方。
4. 接收方 接收到消息后进行解密。
5. 所以客户端其实也看不到消息内容【端对端加密】



### 2）获取秘钥

![img](https://cdn.nlark.com/yuque/0/2024/png/38627688/1713757012821-40f3144c-1cbf-4b16-8953-1e95a61b94a6.png)

**此阶段的通信安全特点：**
每次通信前，进行密钥协商，一次一密。
密钥协商过程，如上图所述，需要随机生成三次密钥，两次非对称加密密钥（公钥，私钥），一次对称加密密钥，简称安全信道建立的“三次握手”，在客户端发起安全信道建立请求后：

- 服务端随机生成公私钥对(公钥pk1，私钥pk2)，并将公钥pk1传给客户端：
  (注意：此时黑客能截获pk1)；
- 客户端随机生成公私钥对(公钥pk11，私钥pk22)，并将公钥pk11，通过pk1加密，传给服务端：
  (注意：此时黑客能截获密文，也知道是通过pk1加密的，但由于黑客不知道私钥pk2，是无法解密的)；
- 服务端收到密文，用私钥pk2解密，得到pk11；
- 服务端随机生成对称加密密钥key=X，用pk11加密，传给客户端：
  (注意：同理，黑客由密文无法解密出key)；
- 客户端收到密文，用私钥pk22解密，可到key=X。

至此，安全信道建立完毕，后续通讯用key=X加密，以保证信息的安全性。

前提条件：用户只在同一台机器登录。即【共享密钥不会改变】

因为共享密钥需要保存到本地，如果换了机器，需要重新创建（这样就导致每次登录都要换新，换新就会导致每次共享密钥会变，导致解码不了）。

### 3）私聊

客户端不需要处理私聊的消息了，直接把 ByteString 类型的消息转化为 String 存起来就行，发送的时候再转回ByteString

![img](https://cdn.nlark.com/yuque/0/2024/png/38627688/1713794426301-0d732711-bc44-48ef-80af-e427d41ce364.png)

### 4）群聊

客户端需要处理群聊消息，客户端解码后存储明文消息，发送时再用 共享密钥加密。

![img](https://cdn.nlark.com/yuque/0/2024/png/38627688/1713794432088-9ffae844-32b3-4efa-a787-962a732bb20c.png)

- 消息加密解密都在 processor 中进行。



## 六、应用安全性保证

### 1）认证

1. 可以使用 用户名、密码 登录，也使用 OAuth2 实现了 Gitee 的社交登录。
2. 用户登录时 ，服务端生成 access_token 和 refresh_token ，access_token 过期时间较短 ，返回给客户端，用于访问接口；refresh_token 过期时间较长，用于刷新 access_token ，不需要用户频繁登录。

### 2）授权

1. 采用 RBAC 用户-角色-权限的授权模式，一个用户可以拥有多个角色，一个角色可以有多个权限，方便改变用户的权限。
2. 用户访问接口时，请求头要带上认证后的access_token ，access_token中有用户的权限信息，认证过滤器查询对应接口所需权限，再比对用户所拥有的权限来决定是否放行。



## 七、升级

### 1）使用kafka削峰

- 1）PushProxy：接受用户的推送请求，写入Kafka；
- 2）PushServer：从Kafka获取推送请求，判断用户是否在线；
- 3）PushWorker：真正推送的服务，将消息体写入channel。



升级方面：推送系统从 【接收到立即推送】 升级为 【接收消息后，将需要推送的消息放入kafka消息队列，由kafka的监听者来 监听 推送消息的到来，逐条处理】

优点：消息在服务端和客户端的接收速度，及 消息发送后 ack的速度都有明显加快。

### 2）使用延迟队列 + 死信队列 代替redis的过期监听器

升级前：使用redis 的过期监听器等待发送的消息ack时，会占用redis 的大量资源，导致redis 性能下降，多次出现因redis性能问题的 消息重发，消息过期。

升级方面：使用延迟队列 + 死信队列代替redis的过期监听器，当消息发送出去需要等待 对方 ack时，将该消息的unqiueId 和 重试次数 存入到延迟队列，并把发送的消息缓存到redis，用于重发。当延迟队列中的消息过期时，到redis 中查看消息缓存是否还在，如果在，说明消息没有收到ack，需要重发；如果不在，说明消息已经被ack了。

优点：取消了redis的过期键监听，有效地提升了redis的性能。

缺点：并没有完全脱离redis的使用，还是要把发送的消息缓存到redis中，用于重发。